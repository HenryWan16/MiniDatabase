package simpledb;
import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {
	private JoinPredicate p = null;
	private DbIterator child1 = null;
	private DbIterator child2 = null;
	private Iterator joinIterator = null;
	private TupleDesc joinTupleDesc = null;
	private ArrayList<Tuple> list = null;

//	public class JoinIterator implements DbFileIterator
//	{
//		/**
//		 * 把join操作中满足Predicate的Tuple都放到ArrayList里面并返回迭代器
//		 */
//		private Iterator<Tuple> it;
//		
//		public JoinIterator() throws NoSuchElementException, DbException, TransactionAbortedException
//		{
//			this.it = list.iterator();
//		}
//		
//		@Override
//		public void open() throws DbException, TransactionAbortedException {
//			// TODO Auto-generated method stub
//			this.it = list.iterator();
//		}
//
//		@Override
//		public boolean hasNext() throws DbException,
//				TransactionAbortedException {
//			// TODO Auto-generated method stub
//			if (this.it == null)
//			{
//				return false;
//			}
//			else
//			{
//				return this.it.hasNext();
//			}
//		}
//
//		@Override
//		public Tuple next() throws DbException, TransactionAbortedException,
//				NoSuchElementException {
//			// TODO Auto-generated method stub
//			if (this.it.hasNext())
//			{
//				return this.it.next();
//			}
//			else
//			{
//				throw new NoSuchElementException("tuple is null (After join)");
//			}
//		}
//
//		@Override
//		public void rewind() throws DbException, TransactionAbortedException {
//			// TODO Auto-generated method stub
//			this.close();
//			this.open();
//		}
//
//		@Override
//		public void close() {
//			// TODO Auto-generated method stub
//			this.it = null;
//		}
//		
//	}
	
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2)  
    {
        // some code goes here
    	this.p = p;
    	this.child1 = child1;
    	this.child2 = child2;
    	this.joinTupleDesc = this.getTupleDesc();
    	this.list = new ArrayList<Tuple>();
    	Tuple tuple1 = null;
		Tuple tuple2 = null;
		Tuple joinTuple = null;
		
		// 必须要在进入下次while循环之前将DbIterator重置为表2的开始位置
		DbIterator t1 = this.child1;
		try {
			while (t1.hasNext())
			{
				tuple1 = t1.next();
				DbIterator t2 = child2;
				while (t2.hasNext())
				{
					tuple2 = t2.next();
					if (p.filter(tuple1, tuple2))
			    	{
			    		joinTuple = setJoinTuple(tuple1, tuple2);
			    		this.list.add(joinTuple);
			    	}
				}
				child2.rewind();
			}
			child1.rewind();
			this.joinIterator = this.list.iterator();
		} catch (DbException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransactionAbortedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchElementException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }

    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
        // some code goes here
    	TupleDesc td1 = this.child1.getTupleDesc();
    	TupleDesc td2 = this.child2.getTupleDesc();
    	this.joinTupleDesc = td1.combine(td1, td2);
        return this.joinTupleDesc;
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException {
        // some code goes here
    	this.joinIterator = this.list.iterator();
    }

    public void close() {
        // some code goes here
    	this.joinIterator = null;
    }

    public void rewind() throws DbException, TransactionAbortedException {
        // some code goes here
    	this.close();
    	this.open();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, if an equality predicate is used 
     * there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
        // some code goes here
    	Tuple tuple = null;
    	if (this.joinIterator.hasNext())
    	{
    		tuple = (Tuple) this.joinIterator.next();
    	}
        return tuple;
    }
    
    /**
     * 把两个子记录合并，填充joinTuple里面的各个属性
     * 仅仅只合并生成一条新的Tuple记录，保存在this.joinTuple里面
     * Written by Wh
     * @throws TransactionAbortedException 
     * @throws DbException 
     * @throws NoSuchElementException 
     */
    public Tuple setJoinTuple(Tuple tuple1, Tuple tuple2) throws NoSuchElementException, DbException, TransactionAbortedException
    {
    	int i = 0;
    	int length = 0;
    	TupleDesc tupleDesc = this.getTupleDesc();
    	Tuple joinTuple = new Tuple(tupleDesc);
    	
    	// 把Tuple1拷贝到新的Tuple里面
    	length = tuple1.getTupleDesc().numFields();
    	for (i = 0; i < length; i++)
    	{
    		joinTuple.setField(i, tuple1.getField(i));
    	}
    	
    	// 把Tuple2拷贝到新的Tuple里面
    	int begin = i;
    	length = tuple2.getTupleDesc().numFields();
    	// 接着Tuple1结束的位置往后面拷贝，所以不用for循环把i置为0
    	while ((i - begin) < length)
   		{
   			joinTuple.setField(i, tuple2.getField(i - begin));
   			i++;
   		}
    	return joinTuple;
    }
}
